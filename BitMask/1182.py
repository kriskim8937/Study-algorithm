##10971 외판원 순회 비트마스크로 풀기
## dfs 롣도 풀수 있지만, 비트마스크가 훨씬 빠른 알고리즘 
## 시작은 0 번도시, 2번째 도시로 이동후 비용 저장
## 시작 도시 포함해서 3개 부터 N개까지 방문한 비트 마스크 조합을 만들어냄
## (12)3, (13)2, 등을 비교해서 비용이 작은값을 저장
## 그것을 N개까지 반복,
## 마지막에 돌아오는 것까지 제일 적은 루트의 최소비용을 출력
from itertools import combinations
def convert(s):
    s = int(s)
    if s == 0:
        return float('inf')
    return s
#입력을 int형으로 바꿔주고, 0을 inf 로 바꿔줌
n = int(input())
w = [list(map(convert,input().split())) for i in range(n)]
C = {}#딕셔너리 선언 (들린도시 비트마스크1111, 현재있는도시1,2,3) 

def TSP(n, w):
    #n은 도시의 개수, w는 비용
    for k in range(1, n):#k는 1부터 n-1
        C[(1+(1<<k),k)] = w[0][k] #딕셔너리  (0011,1):10 (0101,2):15 (1001,3):20
        #출발은 0번재 도시, 0번재에서 다른 도시로 이동후 비용 저장 
    print(C)
    for s in range(2, n+1):#s는 2부터 n까지 리스트(몇개 도시 갔는지)  --- 2라고 가정 ,3,4
        for S in combinations(range(1,n ), s):#S는 1부터 n-1까지 중에 s개(2~n개) 조합 튜플 --- 2개방문한 조합 (1,2),(1,3),(2,3)
            val = sum(1<<k for k in S)+1 #1 ~ n-1 의숫자에서 2~n개의 모든 조합을 비트 마스크로 만듬0도체크 
            #0번째도시를 포함하고, 나머지 도시중에 2개 이상 방문한 조합 만들어냄 
            # 0111 , 1011, 1101, 1111 
            print(val)
            for k in S: #k = 0001 0101 1001 1011 ...1111
                C[(val,k)] = min(C[(val-(1<<k),m)]+w[m][k] for m in S if m!=0 and m!=k)
                #모든 도시를 돌지 않고 첫번째 도시로 돌아가거나, 같은 도시로 이동하는 경우의 수 제외 
    print(C)     
    return min(C[((2<<n-1)-1,k)] + w[k][0] for k in range(1,n))
    # C[(1111(15),1),(1111(15),2),(1111(15),3)중에 돌아가는 것까지 합쳐서 제일 작은값
    # (1111(15),2)= 29 +6 = 35
print(TSP(n,w)) 
